---
layout: post
title: ESP32 GPIO
author: [Richard Kuo]
category: [Lecture]
tags: [jekyll, ai]
---

Introduction to GPIO debounce, pullup, interrupt and OneWire interface to DS18B20, DHT11.

---
## MCU - Micro Control Unit (Microcontroller)
A MCU consist of a processor core, memory and I/O interfaces

NodeMCU-32S pinout<br>
![](https://github.com/rkuo2000/MCU-course/blob/main/images/NodeMCU-32S_pinout.jpg?raw=true)

---
## GPIO (General Purpose I/O)
![](https://github.com/rkuo2000/MCU-course/blob/main/images/GPIO_circuit_diagram.png?raw=true)

Each IO pad drive/sink **~25mA**, Entire Chip drive/sink **~200mA**<br>
![](https://github.com/rkuo2000/MCU-course/blob/main/images/GPIO_LED_circuit.png?raw=true)

---
### Examples/01.Basics/Blink
* NodeMCU-32S has a built-in LED on GPIO2.<br>
`#define LED_BUILTIN 2`

**setup()**<br>

*To setup MCU's default value, setup() is run only once after power-up or reset*<br>
```
void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
}
```

**loop()**<br>

*The main is loop() that keeps running forever.*<br>
```
// the loop function runs over and over again forever
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
  delay(1000);                       // wait for a second
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
  delay(1000);                       // wait for a second
}
```

---
### Examples/01.Basics/DigitalReadSerial

* Onboard Button BOOT/IO is connected to GPIO0
* Modify to pushButton =2, so we can read BOOT button status.<br>
`int pushButton = 0;`


```
// the setup routine runs once when you press reset:
void setup() {
  // initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
  // make the pushbutton's pin an input:
  pinMode(pushButton, INPUT);
}

// the loop routine runs over and over again forever:
void loop() {
  // read the input pin:
  int buttonState = digitalRead(pushButton);
  // print out the state of the button:
  Serial.println(buttonState);
  delay(1);        // delay in between reads for stability
}
```

* Open the monitor & set 9600 baud to see serial print-out from running program in Arduino IDE.
![](https://github.com/rkuo2000/MCU-course/blob/main/images/GPIO_read_BOOT_button.png?raw=true)
* Press BOOT(IO0) button will see readout changed to 0, release BOOT button will see readout =1
* If change to Serial.begin(115200), then change monitor to 115200 baud to match the serial baudrate.

---
### Examples/02.Digital/Button

* Ths example is to read the buttonPin state, then output to the state (High/Low) to ledPin
* Modify pin IOs (buttonpin =0; ledPin =2)<br>
`const int buttonPin = 0;` (using BOOT/IO0 button)<br>
`const int ledPin =2;` (output to built-in LED)<br>

```
// constants won't change. They're used here to set pin numbers:
const int buttonPin = 2;     // the number of the pushbutton pin
const int ledPin =  13;      // the number of the LED pin

// variables will change:
int buttonState = 0;         // variable for reading the pushbutton status

void setup() {
  // initialize the LED pin as an output:
  pinMode(ledPin, OUTPUT);
  // initialize the pushbutton pin as an input:
  pinMode(buttonPin, INPUT);
}

void loop() {
  // read the state of the pushbutton value:
  buttonState = digitalRead(buttonPin);

  // check if the pushbutton is pressed. If it is, the buttonState is HIGH:
  if (buttonState == HIGH) {
    // turn LED on:
    digitalWrite(ledPin, HIGH);
  } else {
    // turn LED off:
    digitalWrite(ledPin, LOW);
  }
}
```

---
### Examples/02.Digital/Debounce

* This example is to add debounce-delay before reading the buttonPin.
* Modify pin IOs (buttonpin =0; ledPin =2)<br>
`unsigned long debounceDelay = 50; ` (50ms duration for reading GPIO0 button)<br>

```
// constants won't change. They're used here to set pin numbers:
const int buttonPin = 0;    // the number of the pushbutton pin
const int ledPin = 2;      // the number of the LED pin

// Variables will change:
int ledState = HIGH;         // the current state of the output pin
int buttonState;             // the current reading from the input pin
int lastButtonState = LOW;   // the previous reading from the input pin

// the following variables are unsigned longs because the time, measured in
// milliseconds, will quickly become a bigger number than can be stored in an int.
unsigned long lastDebounceTime = 0;  // the last time the output pin was toggled
unsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers

void setup() {
  pinMode(buttonPin, INPUT);
  pinMode(ledPin, OUTPUT);

  // set initial LED state
  digitalWrite(ledPin, ledState);
}

void loop() {
  // read the state of the switch into a local variable:
  int reading = digitalRead(buttonPin);

  // check to see if you just pressed the button
  // (i.e. the input went from LOW to HIGH), and you've waited long enough
  // since the last press to ignore any noise:

  // If the switch changed, due to noise or pressing:
  if (reading != lastButtonState) {
    // reset the debouncing timer
    lastDebounceTime = millis();
  }

  if ((millis() - lastDebounceTime) > debounceDelay) {
    // whatever the reading is at, it's been there for longer than the debounce
    // delay, so take it as the actual current state:

    // if the button state has changed:
    if (reading != buttonState) {
      buttonState = reading;

      // only toggle the LED if the new button state is HIGH
      if (buttonState == HIGH) {
        ledState = !ledState;
      }
    }
  }

  // set the LED:
  digitalWrite(ledPin, ledState);

  // save the reading. Next time through the loop, it'll be the lastButtonState:
  lastButtonState = reading;
}
```

---
### Examples/02.Digital/DigitalInputPullup

* Configure pin 0 as an input and enable the internal pull-up resistor<br>
`pinMode(0, INPUT_PULLUP);`<br>
`pinMode(2, OUTPUT);`<br>
 
```
void setup() {
  //start serial connection
  Serial.begin(9600);
  //configure pin 2 as an input and enable the internal pull-up resistor
  pinMode(0, INPUT_PULLUP);
  pinMode(2, OUTPUT);

}

void loop() {
  //read the pushbutton value into a variable
  int sensorVal = digitalRead(2);
  //print out the value of the pushbutton
  Serial.println(sensorVal);

  // Keep in mind the pull-up means the pushbutton's logic is inverted. It goes
  // HIGH when it's open, and LOW when it's pressed. Turn on pin 13 when the
  // button's pressed, and off when it's not:
  if (sensorVal == HIGH) {
    digitalWrite(2, LOW);
  } else {
    digitalWrite(2, HIGH);
  }
}
```

---
## GPIOs' Interrupt Service Routine (ISR)

---
## 1-Wire Interface
**[Guide to 1-Wire Communication](https://www.maximintegrated.com/en/design/technical-documents/tutorials/1/1796.html)**<br>
The basis of 1-Wire® technology is a serial protocol using a single data line plus ground reference for communication. A 1-Wire master initiates and controls the communication with one or more 1-Wire slave devices on the 1-Wire bus (Figure below). Each 1-Wire slave device has a unique, unalterable, factory-programmed, 64-bit identification number (ID), which serves as device address on the 1-Wire bus. The 8-bit family code, a subset of the 64-bit ID, identifies the device type and functionality. Typically, 1-Wire slave devices operate over the following four voltage ranges:

 - 1.71V (min) to 1.89V (max)
 - 1.71V (min) to 3.63V (max)
 - 2.97V (min) to 3.63V (max)
 - 2.8V (min) to 5.25V (max)

![](https://www.maximintegrated.com/content/dam/images/design/tech-docs/1796/1796Fig01.gif)

*The DS2432 is a 1024 bits of EEPROM with 1-Wire interface*<br>
![](https://upload.wikimedia.org/wikipedia/commons/1/12/1-Wire-Protocol.png)

---
### DS18B20 
![](https://makerpro.cc/wp-content/uploads/2019/05/Introduction-to-DS18B20.jpg)

**[DS1820 Datasheet](https://datasheets.maximintegrated.com/en/ds/DS18B20.pdf)**<br>
Features:<br>
* Unique 1-Wire interface requires only one port pin for communication
* Multidrop capability simplifies distributedtemperature sensing applications
* Requires no external components
* Can be powered from data line. Power supplyrange is 3.0V to 5.5V
* Zero standby power required
* Measures temperatures from -55°C to+125°C. Fahrenheit equivalent is -67°F to+257°F
* ±0.5°C accuracy from -10°C to +85°C
* Thermometer resolution is programmablefrom 9 to 12 bits
* Converts 12-bit temperature to digital word in750 ms (max.)

---
### Install DS18B20 library
**Tools>Managing Libraries>** *select DS18B20 & Install All*

![](https://github.com/rkuo2000/MCU-course/blob/main/images/ArduinoIDE_ManagingLibrary_DS18B20_OneWire.png?raw=true)

**OneWire library**: *~/Documents/Arduino/libraries/OneWire*<br>
**OneWire.h**<br>
**OneWire.cpp**<br>

DS18B20 Initial Timing (Reset)<br>
![](https://github.com/rkuo2000/MCU-course/blob/main/images/DS18B20_initial_timing.png?raw=true)
```
// Perform the onewire reset function.  We will wait up to 250uS for
// the bus to come high, if it doesn't then it is broken or shorted
// and we return a 0;
//
// Returns 1 if a device asserted a presence pulse, 0 otherwise.
//
uint8_t OneWire::reset(void)
{
        IO_REG_TYPE mask IO_REG_MASK_ATTR = bitmask;
        volatile IO_REG_TYPE *reg IO_REG_BASE_ATTR = baseReg;
        uint8_t r;
        uint8_t retries = 125;

        noInterrupts();
        DIRECT_MODE_INPUT(reg, mask);
        interrupts();
        // wait until the wire is high... just in case
        do {
                if (--retries == 0) return 0;
                delayMicroseconds(2);
        } while ( !DIRECT_READ(reg, mask));

        noInterrupts();
        DIRECT_WRITE_LOW(reg, mask);
        DIRECT_MODE_OUTPUT(reg, mask);  // drive output low
        interrupts();
        delayMicroseconds(480);
        noInterrupts();
        DIRECT_MODE_INPUT(reg, mask);   // allow it to float
        delayMicroseconds(70);
        r = !DIRECT_READ(reg, mask);
        interrupts();
        delayMicroseconds(410);
        return r;
}
```
Read Write Timing<br>
![](https://github.com/rkuo2000/MCU-course/blob/main/images/DS18B20_read_write_timing.png?raw=true)

```
void OneWire::write_bit(uint8_t v)
{
        IO_REG_TYPE mask IO_REG_MASK_ATTR = bitmask;
        volatile IO_REG_TYPE *reg IO_REG_BASE_ATTR = baseReg;

        if (v & 1) {
                noInterrupts();
                DIRECT_WRITE_LOW(reg, mask);
                DIRECT_MODE_OUTPUT(reg, mask);  // drive output low
                delayMicroseconds(10);
                DIRECT_WRITE_HIGH(reg, mask);   // drive output high
                interrupts();
                delayMicroseconds(55);
        } else {
                noInterrupts();
                DIRECT_WRITE_LOW(reg, mask);
                DIRECT_MODE_OUTPUT(reg, mask);  // drive output low
                delayMicroseconds(65);
                DIRECT_WRITE_HIGH(reg, mask);   // drive output high
                interrupts();
                delayMicroseconds(5);
        }
}
```

```
uint8_t OneWire::read_bit(void)
{
        IO_REG_TYPE mask IO_REG_MASK_ATTR = bitmask;
        volatile IO_REG_TYPE *reg IO_REG_BASE_ATTR = baseReg;
        uint8_t r;

        noInterrupts();
        DIRECT_MODE_OUTPUT(reg, mask);
        DIRECT_WRITE_LOW(reg, mask);
        delayMicroseconds(3);
        DIRECT_MODE_INPUT(reg, mask);   // let pin float, pull up will raise
        delayMicroseconds(10);
        r = DIRECT_READ(reg, mask);
        interrupts();
        delayMicroseconds(53);
        return r;
}
```

---
### Examples>OneWire>DS18x20_Temperature
* DS18B20 connected to ESP32 GPIO23, and a 10K resistor pull-up to +5V.
![](https://github.com/rkuo2000/MCU-course/blob/main/images/Example_DS18B20.jpg?raw=true)

* Modify DS18x20_Temperature.ino to use GPIO23
![](https://github.com/rkuo2000/MCU-course/blob/main/images/Examples_DS18x20_Temperature.png?raw=true)

* Open ArduinoIDE monitor to see DS18x20_Temperature running.
![](https://github.com/rkuo2000/MCU-course/blob/main/images/Examples_DS18x20_Temperature_monitor.png?raw=true)

---
### DHT11
![](https://github.com/rkuo2000/MCU-course/blob/main/images/DHT11.png?raw=true)

**[DHT11 Datasheet](https://www.mouser.com/datasheet/2/758/DHT11-Technical-Data-Sheet-Translated-Version-1143054.pdf)**<br>
Typical Application
![](https://github.com/rkuo2000/MCU-course/blob/main/images/DHT11_typical_connection.png?raw=true)

Overall Communication Process
![](https://github.com/rkuo2000/MCU-course/blob/main/images/DHT11_overall_communication_process.png?raw=true)

DHT11 Response
![](https://github.com/rkuo2000/MCU-course/blob/main/images/DHT11_response.png?raw=true)

DHT11 Data Transmission
<table>
<tr>
<td><img src="https://github.com/rkuo2000/MCU-course/blob/main/images/DHT11_data_0.png?raw=true"></td>
<td><img src="https://github.com/rkuo2000/MCU-course/blob/main/images/DHT11_data_1.png?raw=true"></td>
</tr>
</table>

### Install DHT11 library
**Tools>Managing Libraries>** *select DHT sensory library & Install All*

![](https://github.com/rkuo2000/MCU-course/blob/main/images/Arduino_Library_DHT11.png?raw=true)

**DHT11 library**: *~/Documents/Arduino/libraries/DHT_sensor_library*<br>
**DHT.h**<br>
**DHT.cpp**<br>

---
### Examples/DHT11 sensor library/DHTtester
![](https://github.com/rkuo2000/MCU-course/blob/main/images/Example_DHT11.png?raw=true)

* modify DHTPIN to GPIO23 & DHTTYPE to DHT11<br>
`#define DHTPIN 23`<br>
`#define DHTTYPE DHT11`<br>
![](https://github.com/rkuo2000/MCU-course/blob/main/images/Examples_DHTtester.png?raw=true)

* Open ArduinoIDE monitor to see DHT11 readout.
![](https://github.com/rkuo2000/MCU-course/blob/main/images/Examples_DHTtester_monitor.png?raw=true)
<br>
<br>

*This site was last updated {{ site.time | date: "%B %d, %Y" }}.*


